<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Ouroboros.Consensus.Util.MonadSTM.RAWLock</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html">Source</a></li><li><a href="&quot;../index.html&quot;">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">ouroboros-consensus-0.1.0.0: Consensus layer for the Ouroboros blockchain protocol</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Ouroboros.Consensus.Util.MonadSTM.RAWLock</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Public API</a></li><li><a href="#g:2">Exposed internals: non-bracketed acquire &amp; release</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A Read-Append-Write (RAW) lock</p><p>Intended for qualified import</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:RAWLock">RAWLock</a> m st</li><li class="src short"><a href="#v:new">new</a> &#8759; (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Util-IOLike.html#t:NoUnexpectedThunks" title="Ouroboros.Consensus.Util.IOLike">NoUnexpectedThunks</a> st) &#8658; st &#8594; m (<a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st)</li><li class="src short"><a href="#v:withReadAccess">withReadAccess</a> &#8759; &#8704; m st a. <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (st &#8594; m a) &#8594; m a</li><li class="src short"><a href="#v:withAppendAccess">withAppendAccess</a> &#8759; &#8704; m st a. <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (st &#8594; m (st, a)) &#8594; m a</li><li class="src short"><a href="#v:withWriteAccess">withWriteAccess</a> &#8759; &#8704; m st a. <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (st &#8594; m (st, a)) &#8594; m a</li><li class="src short"><a href="#v:read">read</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m st</li><li class="src short"><a href="#v:poison">poison</a> &#8759; (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Util-IOLike.html#t:Exception" title="Ouroboros.Consensus.Util.IOLike">Exception</a> e, <a href="Ouroboros-Consensus-Util-CallStack.html#t:HasCallStack" title="Ouroboros.Consensus.Util.CallStack">HasCallStack</a>) &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (<a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Stack.html#t:CallStack" title="GHC.Stack">CallStack</a> &#8594; e) &#8594; m (<a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> st)</li><li class="src short"><a href="#v:unsafeAcquireReadAccess">unsafeAcquireReadAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m st</li><li class="src short"><a href="#v:unsafeReleaseReadAccess">unsafeReleaseReadAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m ()</li><li class="src short"><a href="#v:unsafeAcquireAppendAccess">unsafeAcquireAppendAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m st</li><li class="src short"><a href="#v:unsafeReleaseAppendAccess">unsafeReleaseAppendAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m ()</li><li class="src short"><a href="#v:unsafeAcquireWriteAccess">unsafeAcquireWriteAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; m st</li><li class="src short"><a href="#v:unsafeReleaseWriteAccess">unsafeReleaseWriteAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; st &#8594; m ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Public API</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:RAWLock" class="def">RAWLock</a> m st <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#RAWLock" class="link">Source</a> <a href="#t:RAWLock" class="selflink">#</a></p><div class="doc"><p>A Read-Append-Write (RAW) lock</p><p>A RAW lock allows multiple concurrent readers, at most one appender, which
 is allowed to run concurrently with the readers, and at most one writer,
 which has exclusive access to the lock.</p><p>The following table summarises which roles are allowed to concurrently
 access the RAW lock:</p><pre>         &#9474; Reader &#9474; Appender &#9474; Writer &#9474;
&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
Reader   &#9474;   V    &#9474;     V    &#9474;    X   &#9474;
Appender &#9474;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9474;     X    &#9474;    X   &#9474;
Writer   &#9474;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9474;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9617;&#9474;    X   &#9474;</pre><p>It is important to realise that a RAW lock is intended to control access to
 a piece of in-memory state that should remain in sync with some other state
 that can only be modified using side-effects, e.g., the file system. If,
 for example, you're only maintaining a counter shared by threads, then
 simply use a <code>TVar</code> or an <code>MVar</code>.</p><h1>Example use case: log files</h1><p>A RAW lock is useful, for example, to maintain an in-memory index of log
 files stored on disk.</p><ul><li>To read data from a log file, you need &quot;read&quot; access to the index to
   find out the file and offset where the requested piece of data is stored.
   While holding the RAW lock as a reader, you can perform the IO operation
   to read the data from the right log file. This can safely happen
   concurrently with other read operations.</li><li>To append data to the current log file, you need &quot;append&quot; access to the
   index so you can append an entry to the index and even to add a new log
   file to the index when necessary. While holding the RAW lock as an
   appender, you can perform the IO operation to append the piece of data to
   the current log file and, if necessary start a new log file. Only one
   append can happen concurrently. However, reads can safely happen
   concurrently with appends. Note that the in-memory index is only updated
   <em>after</em> writing to disk.</li><li>To remove the oldest log files, you need &quot;write&quot; access to the index,
   so you can remove files from the index. While holding the RAW lock as a
   writer, you can perform the IO operations to delete the oldest log files.
   No other operations can run concurrently with this operation: concurrent
   reads might try to read from deleted files and a concurrent append could
   try to append to a deleted file.</li></ul><h1>Analogy: Chicken coop</h1><p>Think of readers as chickens, the appender as the rooster, and the writer
 as the fox. All of them want access to the chicken coop, i.e., the state
 protected by the RAW lock.</p><p>We can allow multiple chickens (readers) together in the chicken coop, they
 get along (reasonably) fine. We can also let one rooster (appender) in, but
 not more than one, otherwise he would start fighting with the other rooster
 (conflict with the other appender). We can only let the fox in when all
 chickens and the rooster (if present) have left the chicken coop, otherwise
 the fox would eat them (conflict with the appender and invalidate the
 results of readers, e.g, closing resources readers try to access).</p><h1>Usage</h1><p>To use the lock, use any of the three following operations:</p><ul><li><code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:withReadAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">withReadAccess</a></code></li><li><code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:withAppendAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">withAppendAccess</a></code></li><li><code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:withWriteAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">withWriteAccess</a></code></li></ul><p>If the standard bracketing the above three operations use doesn't suffice,
 use the following three acquire-release pairs:</p><ul><li><code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeAcquireReadAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeAcquireReadAccess</a></code>   &amp; <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeReleaseReadAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeReleaseReadAccess</a></code></li><li><code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeAcquireAppendAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeAcquireAppendAccess</a></code> &amp; <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeReleaseAppendAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeReleaseAppendAccess</a></code></li><li><code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeAcquireWriteAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeAcquireWriteAccess</a></code>  &amp; <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeReleaseWriteAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeReleaseWriteAccess</a></code></li></ul><p>NOTE: an acquire <strong>must</strong> be followed by the corresponding release,
 otherwise the correctness of the lock is not guaranteed and a dead-lock can
 happen.</p><p>NOTE: nested locking of the same lock is not allowed, as you might be
 blocked on yourself.</p><h1>Notes</h1><ul><li>Only use a RAW lock when it is safe to concurrently read and append.</li></ul><ul><li>We do not guarantee fairness for appenders and writers. They will race
   for access each time the RAW lock changes.</li><li>When you have many writers and/or very frequent writes, readers and
   appenders will starve. You could say we have &quot;unfairness&quot;, as writers
   win over readers and appenders. A RAW lock will not be the best fit in
   such a scenario.</li><li>When you have no writers and you only need a read-append lock, consider
   using a <code>StrictMVar</code> instead. The &quot;stale&quot; state can be used by the
   readers.</li><li>The state <code>st</code> is always evaluated to WHNF and is subject to the
   <code><a href="Ouroboros-Consensus-Util-IOLike.html#t:NoUnexpectedThunks" title="Ouroboros.Consensus.Util.IOLike">NoUnexpectedThunks</a></code> check when enabled.</li><li>All public functions are exception-safe.</li></ul></div></div><div class="top"><p class="src"><a id="v:new" class="def">new</a> &#8759; (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Util-IOLike.html#t:NoUnexpectedThunks" title="Ouroboros.Consensus.Util.IOLike">NoUnexpectedThunks</a> st) &#8658; st &#8594; m (<a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st) <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#new" class="link">Source</a> <a href="#v:new" class="selflink">#</a></p><div class="doc"><p>Create a new <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code></p></div></div><div class="top"><p class="src"><a id="v:withReadAccess" class="def">withReadAccess</a> &#8759; &#8704; m st a. <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (st &#8594; m a) &#8594; m a <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#withReadAccess" class="link">Source</a> <a href="#v:withReadAccess" class="selflink">#</a></p><div class="doc"><p>Access the state stored in the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as a reader.</p><p>Will block when there is a writer or when a writer is waiting to take the
 lock.</p></div></div><div class="top"><p class="src"><a id="v:withAppendAccess" class="def">withAppendAccess</a> &#8759; &#8704; m st a. <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (st &#8594; m (st, a)) &#8594; m a <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#withAppendAccess" class="link">Source</a> <a href="#v:withAppendAccess" class="selflink">#</a></p><div class="doc"><p>Access the state stored in the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as an appender.</p><p>NOTE: it must be safe to run the given append action concurrently with
 readers.</p><p>Will block when there is another appender, a writer, or when a writer is
 waiting to take the lock.</p></div></div><div class="top"><p class="src"><a id="v:withWriteAccess" class="def">withWriteAccess</a> &#8759; &#8704; m st a. <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (st &#8594; m (st, a)) &#8594; m a <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#withWriteAccess" class="link">Source</a> <a href="#v:withWriteAccess" class="selflink">#</a></p><div class="doc"><p>Access the state stored in the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as a writer.</p><p>Will block when there is another writer or while there are readers and/or
 an appender.</p></div></div><div class="top"><p class="src"><a id="v:read" class="def">read</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m st <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#read" class="link">Source</a> <a href="#v:read" class="selflink">#</a></p><div class="doc"><p>Read the contents of the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> in an STM transaction.</p><p>Will retry when there is a writer.</p><p>In contrast to <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:withReadAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">withReadAccess</a></code>, this transaction will succeed when there
 is a writer waiting to write, as there is no IO-operation during which the
 lock must be held.</p></div></div><div class="top"><p class="src"><a id="v:poison" class="def">poison</a> &#8759; (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Util-IOLike.html#t:Exception" title="Ouroboros.Consensus.Util.IOLike">Exception</a> e, <a href="Ouroboros-Consensus-Util-CallStack.html#t:HasCallStack" title="Ouroboros.Consensus.Util.CallStack">HasCallStack</a>) &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; (<a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Stack.html#t:CallStack" title="GHC.Stack">CallStack</a> &#8594; e) &#8594; m (<a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> st) <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#poison" class="link">Source</a> <a href="#v:poison" class="selflink">#</a></p><div class="doc"><p>Poison the lock with the given exception. All subsequent access to the
 lock will result in the given exception being thrown.</p><p>Unless the lock has already been poisoned, in which case the original
 exception with which the lock was poisoned will be thrown.</p></div></div><a href="#g:2" id="g:2"><h1>Exposed internals: non-bracketed acquire &amp; release</h1></a><div class="top"><p class="src"><a id="v:unsafeAcquireReadAccess" class="def">unsafeAcquireReadAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m st <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#unsafeAcquireReadAccess" class="link">Source</a> <a href="#v:unsafeAcquireReadAccess" class="selflink">#</a></p><div class="doc"><p>Acquire the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as a reader.</p><p>Will block when there is a writer or when a writer is waiting to take the
 lock.</p><p>Composable with other <code><a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a></code> transactions.</p><p>NOTE: <strong>must</strong> be followed by a call to <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeReleaseReadAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeReleaseReadAccess</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:unsafeReleaseReadAccess" class="def">unsafeReleaseReadAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m () <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#unsafeReleaseReadAccess" class="link">Source</a> <a href="#v:unsafeReleaseReadAccess" class="selflink">#</a></p><div class="doc"><p>Release the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as a reader.</p><p>Doesn't block.</p><p>Composable with other <code><a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a></code> transactions.</p><p>NOTE: <strong>must</strong> be preceded by a call to <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeAcquireReadAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeAcquireReadAccess</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:unsafeAcquireAppendAccess" class="def">unsafeAcquireAppendAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m st <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#unsafeAcquireAppendAccess" class="link">Source</a> <a href="#v:unsafeAcquireAppendAccess" class="selflink">#</a></p><div class="doc"><p>Access the state stored in the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as an appender.</p><p>Will block when there is another appender, a writer, or when a writer is
 waiting to take the lock.</p><p>Composable with other <code><a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a></code> transactions.</p><p>NOTE: <strong>must</strong> be followed by a call to <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeReleaseAppendAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeReleaseAppendAccess</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:unsafeReleaseAppendAccess" class="def">unsafeReleaseAppendAccess</a> <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#unsafeReleaseAppendAccess" class="link">Source</a> <a href="#v:unsafeReleaseAppendAccess" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">&#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">&#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">&#8594; st</td><td class="doc"><p>State to store in the lock</p></td></tr><tr><td class="src">&#8594; <a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a> m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Release the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as an appender.</p><p>Doesn't block.</p><p>Composable with other <code><a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a></code> transactions.</p><p>NOTE: <strong>must</strong> be preceded by a call to <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeAcquireAppendAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeAcquireAppendAccess</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:unsafeAcquireWriteAccess" class="def">unsafeAcquireWriteAccess</a> &#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m &#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st &#8594; m st <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#unsafeAcquireWriteAccess" class="link">Source</a> <a href="#v:unsafeAcquireWriteAccess" class="selflink">#</a></p><div class="doc"><p>Access the state stored in the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as a writer.</p><p>Will block when there is another writer or while there are readers and/or
 an appender.</p><p>Does <em>not</em> compose with other <code><a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a></code> transactions.</p><p>NOTE: <strong>must</strong> be followed by a call to <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeReleaseWriteAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeReleaseWriteAccess</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:unsafeReleaseWriteAccess" class="def">unsafeReleaseWriteAccess</a> <a href="src/Ouroboros.Consensus.Util.MonadSTM.RAWLock.html#unsafeReleaseWriteAccess" class="link">Source</a> <a href="#v:unsafeReleaseWriteAccess" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">&#8759; <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">&#8658; <a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a> m st</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">&#8594; st</td><td class="doc"><p>State to store in the lock</p></td></tr><tr><td class="src">&#8594; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Release the <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#t:RAWLock" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">RAWLock</a></code> as a writer.</p><p>Doesn't block.</p><p>Does <em>not</em> compose with other <code><a href="Ouroboros-Consensus-Util-MonadSTM-NormalForm.html#t:STM" title="Ouroboros.Consensus.Util.MonadSTM.NormalForm">STM</a></code> transactions.</p><p>NOTE: <strong>must</strong> be preceded by a call to <code><a href="Ouroboros-Consensus-Util-MonadSTM-RAWLock.html#v:unsafeAcquireWriteAccess" title="Ouroboros.Consensus.Util.MonadSTM.RAWLock">unsafeAcquireWriteAccess</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>