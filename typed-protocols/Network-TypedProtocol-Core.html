<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Network.TypedProtocol.Core</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Network.TypedProtocol.Core.html">Source</a></li><li><a href="&quot;../index.html&quot;">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">typed-protocols-0.1.0.0: A framework for strongly typed protocols</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.TypedProtocol.Core</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">Defining protocols</a></li><li><a href="#g:3">Engaging in protocols</a></li><li><a href="#g:4">Protocol proofs and tests</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines the core of the typed protocol framework.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="#t:Protocol">Protocol</a> ps <span class="keyword">where</span><ul class="subs"><li><span class="keyword">data</span> <a href="#t:Message">Message</a> ps (st &#8759; ps) (st' &#8759; ps)</li><li><span class="keyword">data</span> <a href="#t:ClientHasAgency">ClientHasAgency</a> (st &#8759; ps)</li><li><span class="keyword">data</span> <a href="#t:ServerHasAgency">ServerHasAgency</a> (st &#8759; ps)</li><li><span class="keyword">data</span> <a href="#t:NobodyHasAgency">NobodyHasAgency</a> (st &#8759; ps)</li><li><a href="#v:exclusionLemma_ClientAndServerHaveAgency">exclusionLemma_ClientAndServerHaveAgency</a> &#8759; &#8704; (st &#8759; ps). <a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a> st &#8594; <a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a> st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a></li><li><a href="#v:exclusionLemma_NobodyAndClientHaveAgency">exclusionLemma_NobodyAndClientHaveAgency</a> &#8759; &#8704; (st &#8759; ps). <a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a> st &#8594; <a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a> st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a></li><li><a href="#v:exclusionLemma_NobodyAndServerHaveAgency">exclusionLemma_NobodyAndServerHaveAgency</a> &#8759; &#8704; (st &#8759; ps). <a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a> st &#8594; <a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a> st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:PeerRole">PeerRole</a><ul class="subs"><li>= <a href="#v:AsClient">AsClient</a></li><li>| <a href="#v:AsServer">AsServer</a></li></ul></li><li class="src short"><span class="keyword">type family</span> <a href="#t:FlipAgency">FlipAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) <span class="keyword">where ...</span></li><li class="src short"><span class="keyword">data</span> <a href="#t:PeerHasAgency">PeerHasAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st &#8759; ps) <span class="keyword">where</span><ul class="subs"><li><a href="#v:ClientAgency">ClientAgency</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a> st) &#8594; <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> <a href="Network-TypedProtocol-Core.html#v:AsClient" title="Network.TypedProtocol.Core">AsClient</a> st</li><li><a href="#v:ServerAgency">ServerAgency</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a> st) &#8594; <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> <a href="Network-TypedProtocol-Core.html#v:AsServer" title="Network.TypedProtocol.Core">AsServer</a> st</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:WeHaveAgency">WeHaveAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) st = <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st</li><li class="src short"><span class="keyword">type</span> <a href="#t:TheyHaveAgency">TheyHaveAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) st = <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> (<a href="Network-TypedProtocol-Core.html#t:FlipAgency" title="Network.TypedProtocol.Core">FlipAgency</a> pr) st</li><li class="src short"><span class="keyword">data</span> <a href="#t:Peer">Peer</a> ps (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st &#8759; ps) m a <span class="keyword">where</span><ul class="subs"><li><a href="#v:Effect">Effect</a> &#8759; m (<a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a) &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</li><li><a href="#v:Done">Done</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a> st) &#8594; a &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</li><li><a href="#v:Yield">Yield</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:WeHaveAgency" title="Network.TypedProtocol.Core">WeHaveAgency</a> pr st) &#8594; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st' m a &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</li><li><a href="#v:Await">Await</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:TheyHaveAgency" title="Network.TypedProtocol.Core">TheyHaveAgency</a> pr st) &#8594; (&#8704; st'. <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st' m a) &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</li></ul></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Introduction</h1></a><div class="doc"><p>A typed protocol between two peers is defined via a state machine: a
 collection of protocol states and protocol messages which are transitions
 between those states.</p><p>Start from the idea that a protocol is some language of messages sent
 between two peers. To specify a protocol is to describe what possible
 sequences of messages are valid. One simple but still relatively expressive
 way to do this is via a state machine: starting from some initial state,
 all possible paths through the state machine gives the set of valid protocol
 traces. This then dictates what a peer participating in a protocol may
 produce and what it must accept.</p><p>In this style we have a fixed number of states and in each state there is
 some number of valid messages that move us on to the next state. This can be
 illustrated as a graph, which can be a helpful form of documentation.</p><p>We further constrain this idea by saying that the two peers will use the
 same state machine and change states in lock-step by sending/receiving
 messages. In this approach, for each protocol state, the description
 dictates which peer has the agency to choose to send a message, while
 correspondingly the other must be prepared to receive the message.</p><p>The views of the two peers are dual. In each state one peer can send any
 message that is valid for the current protocol state while the other
 must be prepared to receive any valid message for current protocol state.</p><p>We can also have terminal protocol states in which neither peer has agency.</p><p>So part of the protocol description is to label each protocol state with
 the peer that has the agency in that state, or none for terminal states.
 We use the labels &quot;client&quot; and &quot;server&quot; for the two peers, but they are
 in fact symmetric.</p></div><a href="#g:2" id="g:2"><h1>Defining protocols</h1></a><div class="doc"><p>The <code><a href="Network-TypedProtocol-Core.html#t:Protocol" title="Network.TypedProtocol.Core">Protocol</a></code> type class bundles up all the requirements for a typed
 protocol, which are in fact all type level constructs. Defining a new
 protocol and making it an instance of the <code><a href="Network-TypedProtocol-Core.html#t:Protocol" title="Network.TypedProtocol.Core">Protocol</a></code> class requires the
 following language extensions:</p><pre>{-# LANGUAGE GADTs, TypeFamilies, DataKinds #-}</pre><p>The type class itself is indexed on a protocol &quot;tag&quot; type. This type
 does double duty as the <em>kind</em> of the <em>types</em> of the protocol states.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Protocol" class="def">Protocol</a> ps <span class="keyword">where</span> <a href="src/Network.TypedProtocol.Core.html#Protocol" class="link">Source</a> <a href="#t:Protocol" class="selflink">#</a></p><div class="doc"><p>The protocol type class bundles up all the requirements for a typed
 protocol.</p><p>Each protocol consists of three things:</p><ul><li>The protocol itself, which is also expected to be the kind of the types
   of the protocol states. The class is indexed on the protocol itself.</li><li>The protocol messages.</li><li>The partition of the protocol states into those in which the client has
   agency, or the server has agency, or neither have agency.</li></ul><p>The labelling of each protocol state with the peer that has agency in that
 state is done by giving a definition to the data families 
 <code><a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a></code>, <code><a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a></code> and <code><a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a></code>. These
 definitions are expected to be singleton-style GADTs with one constructor
 per protocol state.</p><p>Each protocol state must be assigned to only one label. See
 <a href="Network-TypedProtocol-Proofs.html">Network.TypedProtocol.Proofs</a> for more details on this point.</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">data</span> <a id="t:Message" class="def">Message</a> ps (st &#8759; ps) (st' &#8759; ps) <a href="src/Network.TypedProtocol.Core.html#Message" class="link">Source</a> <a href="#t:Message" class="selflink">#</a></p><div class="doc"><p>The messages for this protocol. It is expected to be a GADT that is
 indexed by the <code>from</code> and <code>to</code> protocol states. That is the protocol state
 the message transitions from, and the protocol state it transitions into.
 These are the edges of the protocol state transition system.</p></div><p class="src"><span class="keyword">data</span> <a id="t:ClientHasAgency" class="def">ClientHasAgency</a> (st &#8759; ps) <a href="src/Network.TypedProtocol.Core.html#ClientHasAgency" class="link">Source</a> <a href="#t:ClientHasAgency" class="selflink">#</a></p><div class="doc"><p>Tokens for those protocol states in which the client has agency.</p></div><p class="src"><span class="keyword">data</span> <a id="t:ServerHasAgency" class="def">ServerHasAgency</a> (st &#8759; ps) <a href="src/Network.TypedProtocol.Core.html#ServerHasAgency" class="link">Source</a> <a href="#t:ServerHasAgency" class="selflink">#</a></p><div class="doc"><p>Tokens for those protocol states in which the server has agency.</p></div><p class="src"><span class="keyword">data</span> <a id="t:NobodyHasAgency" class="def">NobodyHasAgency</a> (st &#8759; ps) <a href="src/Network.TypedProtocol.Core.html#NobodyHasAgency" class="link">Source</a> <a href="#t:NobodyHasAgency" class="selflink">#</a></p><div class="doc"><p>Tokens for terminal protocol states in which neither the client nor
 server has agency.</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:exclusionLemma_ClientAndServerHaveAgency" class="def">exclusionLemma_ClientAndServerHaveAgency</a> &#8759; &#8704; (st &#8759; ps). <a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a> st &#8594; <a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a> st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a> <a href="src/Network.TypedProtocol.Core.html#exclusionLemma_ClientAndServerHaveAgency" class="link">Source</a> <a href="#v:exclusionLemma_ClientAndServerHaveAgency" class="selflink">#</a></p><div class="doc"><p>Lemma that if the client has agency for a state, there are no
 cases in which the server has agency for the same state.</p></div><p class="src"><a id="v:exclusionLemma_NobodyAndClientHaveAgency" class="def">exclusionLemma_NobodyAndClientHaveAgency</a> &#8759; &#8704; (st &#8759; ps). <a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a> st &#8594; <a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a> st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a> <a href="src/Network.TypedProtocol.Core.html#exclusionLemma_NobodyAndClientHaveAgency" class="link">Source</a> <a href="#v:exclusionLemma_NobodyAndClientHaveAgency" class="selflink">#</a></p><div class="doc"><p>Lemma that if the nobody has agency for a state, there are no
 cases in which the client has agency for the same state.</p></div><p class="src"><a id="v:exclusionLemma_NobodyAndServerHaveAgency" class="def">exclusionLemma_NobodyAndServerHaveAgency</a> &#8759; &#8704; (st &#8759; ps). <a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a> st &#8594; <a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a> st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a> <a href="src/Network.TypedProtocol.Core.html#exclusionLemma_NobodyAndServerHaveAgency" class="link">Source</a> <a href="#v:exclusionLemma_NobodyAndServerHaveAgency" class="selflink">#</a></p><div class="doc"><p>Lemma that if the nobody has agency for a state, there are no
 cases in which the server has agency for the same state.</p></div></div></div><div class="doc"><p>The <code>connect</code> and <code>connectPipelined</code> proofs rely on lemmas about the
 protocol. Specifically they rely on the property that each protocol state
 is labelled with the agency of one peer or the other, or neither, but never
 both. Or to put it another way, the protocol states should be partitioned
 into those with agency for one peer, or the other or neither.</p><p>The way the labelling is encoded does not automatically enforce this
 property. It is technically possible to set up the labelling for a protocol
 so that one state is labelled as having both peers with agency, or declaring
 simultaneously that one peer has agency and that neither peer has agency
 in a particular state.</p><p>So the overall proofs rely on lemmas that say that the labelling has been
 done correctly. This type bundles up those three lemmas.</p><p>Specifically proofs that it is impossible for a protocol state to have:</p><ul><li>client having agency and server having agency</li><li>client having agency and nobody having agency</li><li>server having agency and nobody having agency</li></ul><p>These lemmas are structured as proofs by contradiction, e.g. stating
 &quot;if the client and the server have agency for this state then it leads to
 contradiction&quot;. Contradiction is represented as the <code><a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a></code> type that has
 no values except &#8869;.</p><p>For example for the ping/pong protocol, it has three states, and if we set
 up the labelling correctly we have:</p><pre>data PingPong where
  StIdle :: PingPong
  StBusy :: PingPong
  StDone :: PingPong

instance Protocol PingPong where

  data ClientHasAgency st where
    TokIdle :: ClientHasAgency StIdle

  data ServerHasAgency st where
    TokBusy :: ServerHasAgency StBusy

  data NobodyHasAgency st where
    TokDone :: NobodyHasAgency StDone</pre><p>So now we can prove that if the client has agency for a state then there
 are no cases in which the server has agency.</p><pre>  exclusionLemma_ClientAndServerHaveAgency TokIdle tok = case tok of {}</pre><p>For this protocol there is only one state in which the client has agency,
 the idle state. By pattern matching on the state token for the server
 agency we can list all the cases in which the server also has agency for
 the idle state. There are of course none of these so we give the empty
 set of patterns. GHC can check that we are indeed correct about this.
 This also requires the <code>EmptyCase</code> language extension.</p><p>To get this completeness checking it is important to compile modules
 containing these lemmas with <code>-Wincomplete-patterns</code>, which is implied by
 <code>-Wall</code>.</p><p>All three lemmas follow the same pattern.</p></div><a href="#g:3" id="g:3"><h1>Engaging in protocols</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:PeerRole" class="def">PeerRole</a> <a href="src/Network.TypedProtocol.Core.html#PeerRole" class="link">Source</a> <a href="#t:PeerRole" class="selflink">#</a></p><div class="doc"><p>Types for client and server peer roles. As protocol can be viewed from
 either client or server side.</p><p>Note that technically &quot;client&quot; and &quot;server&quot; are arbitrary labels. The
 framework is completely symmetric between the two peers.</p><p>This definition is only used as promoted types and kinds, never as values.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:AsClient" class="def">AsClient</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:AsServer" class="def">AsServer</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type family</span> <a id="t:FlipAgency" class="def">FlipAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) <span class="keyword">where ...</span> <a href="src/Network.TypedProtocol.Core.html#FlipAgency" class="link">Source</a> <a href="#t:FlipAgency" class="selflink">#</a></p><div class="doc"><p>A type function to flip the client and server roles.</p></div><div class="subs equations"><p class="caption">Equations</p><table><tr><td class="src"><a href="Network-TypedProtocol-Core.html#t:FlipAgency" title="Network.TypedProtocol.Core">FlipAgency</a> <a href="Network-TypedProtocol-Core.html#v:AsClient" title="Network.TypedProtocol.Core">AsClient</a> = <a href="Network-TypedProtocol-Core.html#v:AsServer" title="Network.TypedProtocol.Core">AsServer</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Network-TypedProtocol-Core.html#t:FlipAgency" title="Network.TypedProtocol.Core">FlipAgency</a> <a href="Network-TypedProtocol-Core.html#v:AsServer" title="Network.TypedProtocol.Core">AsServer</a> = <a href="Network-TypedProtocol-Core.html#v:AsClient" title="Network.TypedProtocol.Core">AsClient</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:PeerHasAgency" class="def">PeerHasAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st &#8759; ps) <span class="keyword">where</span> <a href="src/Network.TypedProtocol.Core.html#PeerHasAgency" class="link">Source</a> <a href="#t:PeerHasAgency" class="selflink">#</a></p><div class="doc"><p>This data type is used to hold state tokens for states with either client
 or server agency. This GADT shows up when writing protocol peers, when
 <code><a href="Network-TypedProtocol-Core.html#v:Yield" title="Network.TypedProtocol.Core">Yield</a></code>ing or <code><a href="Network-TypedProtocol-Core.html#v:Await" title="Network.TypedProtocol.Core">Await</a></code>ing, and when writing message encoders/decoders.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:ClientAgency" class="def">ClientAgency</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a> st) &#8594; <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> <a href="Network-TypedProtocol-Core.html#v:AsClient" title="Network.TypedProtocol.Core">AsClient</a> st</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:ServerAgency" class="def">ServerAgency</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a> st) &#8594; <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> <a href="Network-TypedProtocol-Core.html#v:AsServer" title="Network.TypedProtocol.Core">AsServer</a> st</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><details id="i:PeerHasAgency" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:PeerHasAgency:Show:1"></span> (&#8704; (st' &#8759; ps). <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a> st'), &#8704; (st' &#8759; ps). <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a> st')) &#8658; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st)</span> <a href="src/Network.TypedProtocol.Core.html#line-329" class="link">Source</a> <a href="#t:PeerHasAgency" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:PeerHasAgency:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Network-TypedProtocol-Core.html">Network.TypedProtocol.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> &#8759; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Int.html#t:Int" title="Data.Int">Int</a> &#8594; <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> &#8759; [<a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st] &#8594; <a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:WeHaveAgency" class="def">WeHaveAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) st = <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st <a href="src/Network.TypedProtocol.Core.html#WeHaveAgency" class="link">Source</a> <a href="#t:WeHaveAgency" class="selflink">#</a></p><div class="doc"><p>A synonym for an state token in which &quot;our&quot; peer has agency. This is
 parametrised over the client or server roles. In either case the peer in
 question has agency.</p><p>This shows up when we are sending messages, or dealing with encoding
 outgoing messages.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:TheyHaveAgency" class="def">TheyHaveAgency</a> (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) st = <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> (<a href="Network-TypedProtocol-Core.html#t:FlipAgency" title="Network.TypedProtocol.Core">FlipAgency</a> pr) st <a href="src/Network.TypedProtocol.Core.html#TheyHaveAgency" class="link">Source</a> <a href="#t:TheyHaveAgency" class="selflink">#</a></p><div class="doc"><p>A synonym for an state token in which the other peer has agency. This is
 parametrised over the client or server roles. In either case the other peer
 has agency.</p><p>This shows up when we are receiving messages, or dealing with decoding
 incoming messages.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Peer" class="def">Peer</a> ps (pr &#8759; <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st &#8759; ps) m a <span class="keyword">where</span> <a href="src/Network.TypedProtocol.Core.html#Peer" class="link">Source</a> <a href="#t:Peer" class="selflink">#</a></p><div class="doc"><p>A description of a peer that engages in a protocol.</p><p>The protocol describes what messages peers <em>may</em> send or <em>must</em> accept.
 A particular peer implementation decides what to actually do within the
 constraints of the protocol.</p><p>Peers engage in a protocol in either the client or server role. Of course
 the client role can only interact with the serve role for the same protocol
 and vice versa.</p><p><code><a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a></code> has several type arguments:</p><ul><li>the protocol itself;</li><li>the client/server role;</li><li>.the current protocol state;</li><li>the monad in which the peer operates; and</li><li>the type of any final result once the peer terminates.</li></ul><p>For example:</p><pre>pingPongClientExample :: Int -&gt; Peer PingPong AsClient StIdle m ()
pingPongServerExample ::        Peer PingPong AsServer StIdle m Int</pre><p>The actions that a peer can take are:</p><ul><li>to perform local monadic effects</li><li>to terminate with a result (but only in a terminal protocol state)</li><li>to send a message (but only in a protocol state in which we have agency)</li><li>to wait to receive a message (but only in a protocol state in which the
   other peer has agency)</li></ul><p>In the <code><a href="Network-TypedProtocol-Core.html#v:Done" title="Network.TypedProtocol.Core">Done</a></code>, <code><a href="Network-TypedProtocol-Core.html#v:Yield" title="Network.TypedProtocol.Core">Yield</a></code> and <code><a href="Network-TypedProtocol-Core.html#v:Await" title="Network.TypedProtocol.Core">Await</a></code> cases we must provide evidence of both
 the protocol state we are in and that the appropriate peer has agency.
 This takes the form of <code><a href="Network-TypedProtocol-Core.html#v:ClientAgency" title="Network.TypedProtocol.Core">ClientAgency</a></code> or <code><a href="Network-TypedProtocol-Core.html#v:ServerAgency" title="Network.TypedProtocol.Core">ServerAgency</a></code> applied to a
 protocol-specific state token: either a <code><a href="Network-TypedProtocol-Core.html#t:ClientHasAgency" title="Network.TypedProtocol.Core">ClientHasAgency</a></code> or a
 <code><a href="Network-TypedProtocol-Core.html#t:ServerHasAgency" title="Network.TypedProtocol.Core">ServerHasAgency</a></code> token for the protocol. The <code><a href="Network-TypedProtocol-Core.html#v:Done" title="Network.TypedProtocol.Core">Done</a></code> state does not need
 the extra agency information.</p><p>While this evidence must be provided, the types guarantee that it is not
 possible to supply incorrect evidence.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Effect" class="def">Effect</a> &#8759; m (<a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a) &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</td><td class="doc"><p>Perform a local monadic effect and then continue.</p><p>Example:</p><pre>Effect $ do
  ...          -- actions in the monad
  return $ ... -- another Peer value</pre></td></tr><tr><td class="src"><a id="v:Done" class="def">Done</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a> st) &#8594; a &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</td><td class="doc"><p>Terminate with a result. A state token must be provided from the
 <code><a href="Network-TypedProtocol-Core.html#t:NobodyHasAgency" title="Network.TypedProtocol.Core">NobodyHasAgency</a></code> states, so show that this is a state in which we can
 terminate.</p><p>Example:</p><pre>Yield (ClientAgency TokIdle)
       MsgDone
      (Done TokDone result)</pre></td></tr><tr><td class="src"><a id="v:Yield" class="def">Yield</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:WeHaveAgency" title="Network.TypedProtocol.Core">WeHaveAgency</a> pr st) &#8594; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st' m a &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</td><td class="doc"><p>Send a message to the other peer and then continue. This takes the
 message and the continuation. It also requires evidence that we have
 agency for this protocol state and thus are allowed to send messages.</p><p>Example:</p><pre>Yield (ClientAgency TokIdle) MsgPing $ ...</pre></td></tr><tr><td class="src"><a id="v:Await" class="def">Await</a> &#8759; !(<a href="Network-TypedProtocol-Core.html#t:TheyHaveAgency" title="Network.TypedProtocol.Core">TheyHaveAgency</a> pr st) &#8594; (&#8704; st'. <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st' m a) &#8594; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a</td><td class="doc"><p>Waits to receive a message from the other peer and then continues.
 This takes the the continuation that is supplied with the received
 message. It also requires evidence that the other peer has agency for
 this protocol state and thus we are expected to wait to receive messages.</p><p>Note that the continuation that gets supplied with the message must be
 prepared to deal with <em>any</em> message that is allowed in <em>this</em> protocol
 state. This is why the continuation <em>must</em> be polymorphic in the target
 state of the message (the third type argument of <code><a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a></code>).</p><p>Example:</p><pre>Await (ClientAgency TokIdle) $ \msg -&gt;
case msg of
  MsgDone -&gt; ...
  MsgPing -&gt; ...</pre></td></tr></table></div></div><a href="#g:4" id="g:4"><h1>Protocol proofs and tests</h1></a><div class="doc"><p>The mechanism for labelling each protocol state with the agency does not
 automatically prevent mislabelling, ie giving conflicting labels to a
 single state. It does in fact prevent forgetting to label states in the
 sense that it would not be possible to write protocol peers that make
 progress having entered these unlabelled states.</p><p>This partition property is however crucial for the framework's guarantees.
 The <a href="Network-TypedProtocol-Proofs.html">Network.TypedProtocol.Proofs</a> module provides a way to guarantee for
 each protocol that this property is not violated. It also provides utilities
 helpful for testing protocols.</p></div><div class="doc"><p>The <code>connect</code> and <code>connectPipelined</code> proofs rely on lemmas about the
 protocol. Specifically they rely on the property that each protocol state
 is labelled with the agency of one peer or the other, or neither, but never
 both. Or to put it another way, the protocol states should be partitioned
 into those with agency for one peer, or the other or neither.</p><p>The way the labelling is encoded does not automatically enforce this
 property. It is technically possible to set up the labelling for a protocol
 so that one state is labelled as having both peers with agency, or declaring
 simultaneously that one peer has agency and that neither peer has agency
 in a particular state.</p><p>So the overall proofs rely on lemmas that say that the labelling has been
 done correctly. This type bundles up those three lemmas.</p><p>Specifically proofs that it is impossible for a protocol state to have:</p><ul><li>client having agency and server having agency</li><li>client having agency and nobody having agency</li><li>server having agency and nobody having agency</li></ul><p>These lemmas are structured as proofs by contradiction, e.g. stating
 &quot;if the client and the server have agency for this state then it leads to
 contradiction&quot;. Contradiction is represented as the <code><a href="file:///opt/ghc/8.6.5/share/doc/ghc-8.6.5/html/libraries/base-4.12.0.0/Data-Void.html#t:Void" title="Data.Void">Void</a></code> type that has
 no values except &#8869;.</p><p>For example for the ping/pong protocol, it has three states, and if we set
 up the labelling correctly we have:</p><pre>data PingPong where
  StIdle :: PingPong
  StBusy :: PingPong
  StDone :: PingPong

instance Protocol PingPong where

  data ClientHasAgency st where
    TokIdle :: ClientHasAgency StIdle

  data ServerHasAgency st where
    TokBusy :: ServerHasAgency StBusy

  data NobodyHasAgency st where
    TokDone :: NobodyHasAgency StDone</pre><p>So now we can prove that if the client has agency for a state then there
 are no cases in which the server has agency.</p><pre>  exclusionLemma_ClientAndServerHaveAgency TokIdle tok = case tok of {}</pre><p>For this protocol there is only one state in which the client has agency,
 the idle state. By pattern matching on the state token for the server
 agency we can list all the cases in which the server also has agency for
 the idle state. There are of course none of these so we give the empty
 set of patterns. GHC can check that we are indeed correct about this.
 This also requires the <code>EmptyCase</code> language extension.</p><p>To get this completeness checking it is important to compile modules
 containing these lemmas with <code>-Wincomplete-patterns</code>, which is implied by
 <code>-Wall</code>.</p><p>All three lemmas follow the same pattern.</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>