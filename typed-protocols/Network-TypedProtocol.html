<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Network.TypedProtocol</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link href="xhaddock.css" rel="alternate stylesheet" type="text/css" title="Classic" /><link href="ocean.css" rel="alternate stylesheet" type="text/css" title="Ocean" /><link href="xhaddock.css" rel="alternate stylesheet" type="text/css" title="Classic" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Network.TypedProtocol.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">typed-protocols-0.1.0.0: A framework for strongly typed protocols</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.TypedProtocol</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">Defining and implementing protocols</a><ul><li><a href="#g:3">Protocol proofs and tests</a></li></ul></li><li><a href="#g:4">Running protocols</a></li><li><a href="#g:5">Pipelining protocols</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This package defines the typed protocol framework. This module re-exports
 the public API.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short">module <a href="Network-TypedProtocol-Core.html">Network.TypedProtocol.Core</a></li><li class="src short">module <a href="Network-TypedProtocol-Proofs.html">Network.TypedProtocol.Proofs</a></li><li class="src short">module <a href="Network-TypedProtocol-Driver.html">Network.TypedProtocol.Driver</a></li><li class="src short">module <a href="Network-TypedProtocol-Pipelined.html">Network.TypedProtocol.Pipelined</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Introduction</h1></a><div class="doc"><p>The typed protocol framework is used to define, test and execute protocols.</p><p>It guarantees:</p><ul><li>agreement on which messages can be sent and received;</li><li>the absence of race conditions; and</li><li>the absence of deadlock.</li></ul><p>The trade-off to achieve these guarantees is that it places constraints on
 the kinds of protocol that can be expressed. In particular it requires that
 protocols be defined as a state transition system. It requires for each
 protocol state that exactly one of the two peers be able to send and the
 other must be ready to receive.</p><p>This means it is not possible to express protocols such as TCP where there
 are protocol states where a single peer can both send and receive, however
 it is suitable for most application-level protocols. In particular many
 application-level protocols are completely in-order and synchronous. That
 said, in many (but not all) cases it is possible to pipeline these protocols
 so that network latency can be hidden and full use made of the available
 bandwidth. Special support is provided to run protocols in a pipelined way,
 without having to change the protocol definition.</p><p>The protocols in this framework assume an underlying &quot;reliable ordered&quot;
 connection. A &quot;reliable ordered&quot; connection is a term of art meaning one
 where the receiving end receives any prefix of the messages sent by the
 sending end. It is not reliable in the colloquial sense as it does not
 ensure that anything actually arrives, only that <em>if</em> any message arrives,
 all the previous messages did too, and that they arrive in the order in
 which they were sent.</p><p>The framework also provides:</p><ul><li>an abstraction for untyped channels;</li><li>a codec abstraction for encoding and decoding protocol messages; and</li><li>drivers for running protocol peers with a channel and a codec.</li></ul></div><a href="#g:2" id="g:2"><h1>Defining and implementing protocols</h1></a><div class="doc"><p>The <a href="Network-TypedProtocol-Core.html">Network.TypedProtocol.Core</a> module defines the core of the system.</p><p>Start reading here to understand:</p><ul><li>how to define new protocols; or</li><li>to write peers that engage in a protocol.</li></ul><p>Typed protocol messages need to be converted to and from untyped
 serialised forms to send over a transport channel. So part of defining a new
 protocol is to define the message encoding and the codec for doing the
 encoding and decoding. This is somewhat (but not significantly) more complex
 than defining normal data type serialisation because of the need to decode
 typed protocol messages. The <a href="Network-TypedProtocol-Codec.html">Network.TypedProtocol.Codec</a> module provides
 the codec abstraction to capture this.</p></div><div class="top"><p class="src">module <a href="Network-TypedProtocol-Core.html">Network.TypedProtocol.Core</a></p></div><a href="#g:3" id="g:3"><h2>Protocol proofs and tests</h2></a><div class="doc"><p>There are a few proofs about the framework that we can state and implement
 as Haskell functions (using GADTs and evaluation). A couple of these proofs
 rely on a few lemmas that should be proved for each protocol. The
 <a href="Network-TypedProtocol-Proofs.html">Network.TypedProtocol.Proofs</a> module describes these proof and provides
 the infrastructure for the simple lemmas that need to be implemented for
 each protocol.</p><p>This module also provides utilities helpful for testing protocols.</p></div><div class="top"><p class="src">module <a href="Network-TypedProtocol-Proofs.html">Network.TypedProtocol.Proofs</a></p></div><a href="#g:4" id="g:4"><h1>Running protocols</h1></a><div class="doc"><p>Typed protocols need to be able to send messages over untyped transport
 channels. The <a href="Network-TypedProtocol-Channel.html">Network.TypedProtocol.Channel</a> module provides such an
 abstraction. You can use existing example implementations of this interface
 or define your own to run over other transports.</p><p>Given a protocol peer, and a channel and a codec we can run the protocol
 peer so that it engages in the protocol sending and receiving messages
 over the channel. The <a href="Network-TypedProtocol-Driver.html">Network.TypedProtocol.Driver</a> module provides drivers
 for normal and pipelined peers. </p></div><div class="top"><p class="src">module <a href="Network-TypedProtocol-Driver.html">Network.TypedProtocol.Driver</a></p></div><a href="#g:5" id="g:5"><h1>Pipelining protocols</h1></a><div class="doc"><p>Protocol pipelining is a technique to make effective use of network
 resources.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/1/19/HTTP_pipelining2.svg" /></p><p>As in the above diagram, instead of sending a request and waiting for the
 response before sending the next request, pipelining involves sending all
 three requests back-to-back and waiting for the three replies. The server
 still simply processes the requests in order and the replies come back in
 the same order as the requests were made.</p><p>Not only does this save network latency, one round trip versus three in
 the diagram above, but it also makes effective use of the bandwidth by
 sending requests and replies back-to-back.</p><p>In the example in the diagram it stops after three requests, but such a
 pattern can go on indefinately with messages going in both directions,
 which can saturate the available bandwidth.</p><p>For many (but not all) protocols that can be defined in the <code>typed-protocol</code>
 framework it is possible to take the protocol, without changing the
 protocol's state  machine, and to engage in the protocol in a pipelined way.
 Only the pipelined client has to be written specially. The server side can
 be used unaltered and can be used with either pipelined or non-pipelined
 clients.</p></div><div class="top"><p class="src">module <a href="Network-TypedProtocol-Pipelined.html">Network.TypedProtocol.Pipelined</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>